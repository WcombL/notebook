# 全局唯一ID

如何在分布式环境中，生成全局唯一ID

## UUID

UUID是通用唯一识别码(Universally Unique Identifier)，在其他语言中也叫GUID，可以生成一个长度32位的全局唯一识别码

String uuid = UUID.randomUUID().toString();

UUID虽然能保证生成全局唯一ID,但是32位太长且是无序的,在入库时性能较差

为什么无序的UUID会导致入库性能变差呢？这涉及到B+树索引的分裂。

众所周知，关系型数据库的索引大都是B+树的结构，拿ID字段来举例，索引树的每一个节点都存储着若干个ID。

如果我们的ID按递增的顺序来插入，比如陆续插入8，9，10，新的ID都只会插入到最后一个节点当中。当最后一个节点满了，会裂变出新的节点。这样的插入是性能比较高的插入，因为这样节点的分裂次数最少，而且充分利用了每一个节点的空间。

但是，如果我们的插入完全无序，不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。

## 数据库自增长

为了提高性能，在分布式系统中可以用DB proxy请求不同的分库，每个分库设置不同的初始值，步长和分库数量相等

ID的生成对数据库严重依赖，不但影响性能，而且一旦数据库挂掉，服务将变得不可用

## SnowFlake算法

SnowFlake所生成的ID一共分成四部分：

1.第一位

占用1bit，其值始终是0，没有实际作用。

2.时间戳

占用41bit，精确到毫秒，总共可以容纳约140年的时间。

3.工作机器id

占用10bit，其中高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），做多可以容纳1024个节点。

4.序列号

占用12bit，这个值在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095。

SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？只需要做一个简单的乘法：

同一毫秒的ID数量 = 1024 X 4096 =  4194304

这个数字在绝大多数并发场景下都是够用的。


### SnowFlake算法的优点
- 生成ID时不依赖于DB，完全在内存生成，高性能高可用。
- ID呈趋势递增，后续插入索引树的时候性能较好。

### SnowFlake算法的缺点
依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。