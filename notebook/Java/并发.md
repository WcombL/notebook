# 并发

## 基础知识

### 并发编程的优缺点

1. 为什么要用到并发,其优势是什么
2. 并发编程的缺点
3. 易混淆的概念

**优点**  
- 充分利用多核CPU计算能力
- 方便进行业务拆分，提升应用性能

**缺点**  
- 频繁的上下文切换
  1. 无锁并发编程：可以参照ConcurrentHashMap锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间
  2. CAS算法：乐观锁 Atomic
  3. 使用最少线程：避免创建不需要的线程，如果线程过多会造成大量线程处于等待状态
  4. 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换
- 线程安全：多线程编程最难把握的就是临界区线程安全问题，稍微不注意就会出现死锁，一旦产生死锁系统就不可用
  1. 避免一个线程同时获得多个锁
  2. 避免一个线程在锁内部占用多个资源，尽量保证每个锁只占用一个资源
  3. 尝试使用定时锁，使用lock.tryLock(timeOut)，当超时时当前线程不会阻塞
  4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

同步VS异步  
并发VS并行  
  - 并发指的是多个任务交替进行
  - 并行则是指真正意义上的“同时进行”

阻塞和非阻塞  
临界区  
  - 用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待

> Lmbench3测量上下文切换的时长 vmstat测量上下文切换次数

### 线程的状态和基本操作

1. 如何创建线程
2. 线程状态的转换
3. 线程的基本操作
4. 守护线程Daemon

**创建线程**

- 通过继承Thread类，重写run方法
- 通过实现Runable接口
- 通过Callable接口(线程池)

**线程基本操作**

***interrupted***

中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。  
中断好比其他线程对该线程打了一个招呼。其他线程可以调用该线程的interrupt()方法对其进行中断操作  
同时该线程可以调用isInterrupted()来感知其他线程对其自身的中断操作，从而做出响应  
另外，同样可以调用Thread的静态方法interrupted()对当前线程进行中断操作，该方法会清除中断标志位  

> 当抛出InterruptedException时候，会清除中断标志位，也就是说在调用isInterrupted会返回false

***join***

join方法可以看做是线程间协作的一种方式  
如果一个线程实例A执行了threadB.join(),其含义是：当前线程A会等待threadB线程终止后threadA才会继续执行  

***sleep***

让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器  
如果当前线程获得了锁，sleep方法并不会失去锁

***sleep() VS wait()***

- sleep()方法是Thread的静态方法，而wait是Object实例方法
- 使用wait()必须在同步方法或同步快中调用，必须获得对象锁。而sleep()没有这个限制。
  wait()会释放占用的对象锁，sleep方法并不会失去锁，只会让出CPU
- sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，
  才会离开等待池，并且再次获得CPU时间片才会继续执行

***yield***

当前线程让出CPU，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。  
另外，让出的时间片只会分配 **给当前线程相同优先级** 的线程


**守护线程Daemon**

守护线程是一种特殊的线程，它是系统的守护者。  
与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。  
用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退。  
当一个Java应用，只有守护线程的时候，虚拟机就会自然退出

> 设置守护线程要先于start()方法


## 并发理论

### Java 内存模型以及happens-before规则

1. JMM内存结构
2. 重排序
3. happens-before规则

> 线程安全的问题一般是因为 **主内存和工作内存数据不一致性** 和 **重排序** 导致的

## 并发关键字

### Synchronized

1. 如何使用Synchronized
2. monitor机制
3. Synchronized的happens-before关系
4. Synchronized的内存语义
5. 锁优化
6. 锁升级策略

### Volatile

1. 实现原理
2. happens-before的关系推导
3. 内存语义
4. 内存语义的实现

### final

1. 如何使用
2. final的重排序规则
3. final实现原理
4. final引用不能从构造函数中“溢出”(this逃逸)

### 三大性质总结：原子性，有序性，可见性

1. 原子性：synchronized
2. 可见性：synchronized,volatile
3. 有序性：synchronized,volatile


## Lock体系

### Lock与AbstractQueuedSynchronizer(AQS)

1. Lock和synchronized的比较
2. AQS设计意图
3. 如何使用AQS实现自定义同步组件
4. 可重写的方法
5. AQS提供的模板方法
6. AQS同步队列的数据结构
7. 独占式锁
8. 共享式锁

### 可重入锁ReentrantLock

1. 重入锁的实现原理
2. 公平锁的实现原理
3. 非公平锁的实现原理
4. 公平锁和非公平锁的比较

### 读写锁ReentrantReadWriteLock

1. 如何表示读写状态
2. WriteLock的获取和释放
3. ReadLock的获取和释放
4. 锁降级策略
5. 生成Condition等待队列
6. 应用场景


### Condition的await和signal等待/通知机制

1. 与Object的wait/notify机制相比具有的特性
2. 与Object的wait/notify相对应的方法
3. 底层数据结构
4. await实现原理
5. signal/signalAll实现原理
6. await和signal/signalAll的结合使用

### LockSupport

1. 主要功能
2. 与synchronized阻塞唤醒相比具有的特色


## 并发容器

### ConcurrentHashMap(JDK 1.8版本)

1. 关键属性
2. 重要内部类
3. 涉及到的CAS操作
4. 构造方法
5. put执行流程
6. get执行流程
7. 扩容机制
8. 用于统计size的方法的执行流程
9. 1.8版本的ConcurrentHashMap与之前版本的比较

### CopyOnWriteArrayList

1. 实现原理
2. COW和ReentrantReadWriteLock的区别
3. 应用场景
4. 为什么具有弱一致性
5. COW的缺点

### ConcurrentLinkedQueue

1. 实现原理
2. 数据结构
3. 核心方法
4. HOPS延迟更新的设计意图

### ThreadLocal

1. 实现原理
2. set方法原理
3. get方法原理
4. remove方法原理
5. ThreadLocalMap

### ThreadLocalMap

1. ThreadLocal内存泄漏原理
2. ThreadLocal的最佳实践
3. 应用场景

### BlockingQueue

1. BlockingQueue的基本操作
2. 常用的BlockingQueue


## 线程池(Executor体系)

### 线程池实现原理

1. 为什么要用到线程池
2. 执行流程
3. 构造器各个参数的意义
4. 如何关闭线程池
5. 如何配置线程池

### ScheduledThreadPoolExecutor

1. 类结构
2. 常用方法
3. ScheduledFutureTask
4. DelayedWorkQueue

### FutureTask基本操作总结

1. FutureTask的几种状态
2. get方法
3. cancel方法
4. 应用场景
5. 实现 Runnable接口

## 原子操作类

### Java中atomic包中的原子操作类总结

1. 实现原理
2. 原子更新基本类型
3. 原子更新数组类型
4. 原子更新引用类型
5. 原子更新字段类型


## 并发工具

### CountDownLatch、CyclicBarrier

1. 倒计时器CountDownLatch
2. 循环栅栏CyclicBarrier
3. CountDownLatch与CyclicBarrier的比较

### Semaphore、Exchanger

1. 资源访问控制Semaphore
2. 数据交换Exchanger


## 并发实践

### 生产者与消费者
