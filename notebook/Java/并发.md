# 并发

## 基础知识

### 并发编程的优缺点

1. 为什么要用到并发,其优势是什么
2. 并发编程的缺点
3. 易混淆的概念

**优点**  
- 充分利用多核CPU计算能力
- 方便进行业务拆分，提升应用性能

**缺点**  
- 频繁的上下文切换
  1. 无锁并发编程：可以参照ConcurrentHashMap锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间
  2. CAS算法：乐观锁 Atomic
  3. 使用最少线程：避免创建不需要的线程，如果线程过多会造成大量线程处于等待状态
  4. 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换
- 线程安全：多线程编程最难把握的就是临界区线程安全问题，稍微不注意就会出现死锁，一旦产生死锁系统就不可用
  1. 避免一个线程同时获得多个锁
  2. 避免一个线程在锁内部占用多个资源，尽量保证每个锁只占用一个资源
  3. 尝试使用定时锁，使用lock.tryLock(timeOut)，当超时时当前线程不会阻塞
  4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

同步VS异步  
并发VS并行  
  - 并发指的是多个任务交替进行
  - 并行则是指真正意义上的“同时进行”

阻塞和非阻塞  
临界区  
  - 用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待

>Lmbench3测量上下文切换的时长 vmstat测量上下文切换次数

### 线程的状态和基本操作

1. 如何创建线程
2. 线程状态的转换
3. 线程的基本操作
4. 守护线程Daemon

**创建线程**

- 通过继承Thread类，重写run方法
- 通过实现Runable接口

## 并发理论

### Java 内存模型以及happens-before规则

1. JMM内存结构
2. 重排序
3. happens-before规则

## 并发关键字

### Synchronized

1. 如何使用Synchronized
2. monitor机制
3. Synchronized的happens-before关系
4. Synchronized的内存语义
5. 锁优化
6. 锁升级策略

### Volatile

1. 实现原理
2. happens-before的关系推导
3. 内存语义
4. 内存语义的实现

### final

1. 如何使用
2. final的重排序规则
3. final实现原理
4. final引用不能从构造函数中“溢出”(this逃逸)

### 三大性质总结：原子性，有序性，可见性

1. 原子性：synchronized
2. 可见性：synchronized,volatile
3. 有序性：synchronized,volatile


## Lock体系

### Lock与AbstractQueuedSynchronizer(AQS)

1. Lock和synchronized的比较
2. AQS设计意图
3. 如何使用AQS实现自定义同步组件
4. 可重写的方法
5. AQS提供的模板方法
6. AQS同步队列的数据结构
7. 独占式锁
8. 共享式锁

### 可重入锁ReentrantLock

1. 重入锁的实现原理
2. 公平锁的实现原理
3. 非公平锁的实现原理
4. 公平锁和非公平锁的比较

### 读写锁ReentrantReadWriteLock

1. 如何表示读写状态
2. WriteLock的获取和释放
3. ReadLock的获取和释放
4. 锁降级策略
5. 生成Condition等待队列
6. 应用场景


### Condition的await和signal等待/通知机制

1. 与Object的wait/notify机制相比具有的特性
2. 与Object的wait/notify相对应的方法
3. 底层数据结构
4. await实现原理
5. signal/signalAll实现原理
6. await和signal/signalAll的结合使用

### LockSupport

1. 主要功能
2. 与synchronized阻塞唤醒相比具有的特色


## 并发容器

### ConcurrentHashMap(JDK 1.8版本)

1. 关键属性
2. 重要内部类
3. 涉及到的CAS操作
4. 构造方法
5. put执行流程
6. get执行流程
7. 扩容机制
8. 用于统计size的方法的执行流程
9. 1.8版本的ConcurrentHashMap与之前版本的比较

### CopyOnWriteArrayList

1. 实现原理
2. COW和ReentrantReadWriteLock的区别
3. 应用场景
4. 为什么具有弱一致性
5. COW的缺点

### ConcurrentLinkedQueue

1. 实现原理
2. 数据结构
3. 核心方法
4. HOPS延迟更新的设计意图

### ThreadLocal

1. 实现原理
2. set方法原理
3. get方法原理
4. remove方法原理
5. ThreadLocalMap

### ThreadLocalMap

1. ThreadLocal内存泄漏原理
2. ThreadLocal的最佳实践
3. 应用场景

### BlockingQueue

1. BlockingQueue的基本操作
2. 常用的BlockingQueue


## 线程池(Executor体系)

### 线程池实现原理

1. 为什么要用到线程池
2. 执行流程
3. 构造器各个参数的意义
4. 如何关闭线程池
5. 如何配置线程池

### ScheduledThreadPoolExecutor

1. 类结构
2. 常用方法
3. ScheduledFutureTask
4. DelayedWorkQueue

### FutureTask基本操作总结

1. FutureTask的几种状态
2. get方法
3. cancel方法
4. 应用场景
5. 实现 Runnable接口

## 原子操作类

### Java中atomic包中的原子操作类总结

1. 实现原理
2. 原子更新基本类型
3. 原子更新数组类型
4. 原子更新引用类型
5. 原子更新字段类型


## 并发工具

### CountDownLatch、CyclicBarrier

1. 倒计时器CountDownLatch
2. 循环栅栏CyclicBarrier
3. CountDownLatch与CyclicBarrier的比较

### Semaphore、Exchanger

1. 资源访问控制Semaphore
2. 数据交换Exchanger


## 并发实践

### 生产者与消费者
